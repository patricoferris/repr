type 'a typ = 'a Repr.t
module Id :
  sig
    type 'a t[@@deriving repr]
    include sig val t : 'a Repr.t -> 'a t Repr.t end[@@ocaml.doc "@inline"]
    [@@merlin.hide ]
  end =
  struct
    type 'a t = 'a[@@deriving repr]
    include struct let t a = a end[@@ocaml.doc "@inline"][@@merlin.hide ]
  end 
let __ = Id.t
module Phantom :
  sig
    type _ t = int[@@deriving repr]
    include sig val t : 'a__001_ Repr.t -> 'a__001_ t Repr.t end[@@ocaml.doc
                                                                  "@inline"]
    [@@merlin.hide ]
  end =
  struct
    type _ t = int[@@deriving repr]
    include struct let t _ = Repr.int end[@@ocaml.doc "@inline"][@@merlin.hide
                                                                  ]
  end 
let __ = Phantom.t
module Multiple :
  sig
    type ('a, 'b, 'c) t = {
      foo: 'a ;
      bar: 'b list ;
      baz: ('b * 'c) }[@@deriving repr]
    include
      sig
        val t : 'a Repr.t -> 'b Repr.t -> 'c Repr.t -> ('a, 'b, 'c) t Repr.t
      end[@@ocaml.doc "@inline"][@@merlin.hide ]
  end =
  struct
    type ('a, 'b, 'c) t = {
      foo: 'a ;
      bar: 'b list ;
      baz: ('b * 'c) }[@@deriving repr]
    include
      struct
        let t a b c =
          Repr.sealr
            (Repr.(|+)
               (Repr.(|+)
                  (Repr.(|+)
                     (Repr.record "t" (fun foo bar baz -> { foo; bar; baz }))
                     (Repr.field "foo" a (fun t -> t.foo)))
                  (Repr.field "bar" (Repr.list b) (fun t -> t.bar)))
               (Repr.field "baz" (Repr.pair b c) (fun t -> t.baz)))
      end[@@ocaml.doc "@inline"][@@merlin.hide ]
  end 
let __ = Multiple.t
